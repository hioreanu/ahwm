/* $Id$ */
/* Copyright (c) 2001 Alex Hioreanu.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

#include <X11/Xatom.h>
#include <sys/types.h>
#include <sys/time.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>

#include "xwm.h"
#include "event.h"
#include "client.h"
#include "focus.h"
#include "workspace.h"
#include "keyboard-mouse.h"
#include "xev.h"
#include "malloc.h"
#include "move-resize.h"
#include "debug.h"
#include "ewmh.h"
#include "place.h"
#include "stacking.h"

#ifdef SHAPE
#include <X11/extensions/shape.h>
#endif /* SHAPE */

Time event_timestamp = CurrentTime;

static void event_enter(XCrossingEvent *);
static void event_create(XCreateWindowEvent *);
static void event_destroy(XDestroyWindowEvent *);
static void event_unmap(XUnmapEvent *);
static void event_maprequest(XMapRequestEvent *);
static void event_configurerequest(XConfigureRequestEvent *);
static void event_property(XPropertyEvent *);
static void event_colormap(XColormapEvent *);
static void event_clientmessage(XClientMessageEvent *);
static void event_circulaterequest(XCirculateRequestEvent *);
static void event_expose(XExposeEvent *);
static void event_focusin(XFocusChangeEvent *);
static void event_map(XMapEvent *);

#ifdef SHAPE
static void event_shape(XShapeEvent *);
#endif /* SHAPE */

/*
 * We want to discriminate between EnterNotify events caused by the
 * user moving the mouse and EnterNotify events caused by a change in
 * the window configuration brought about by either this window
 * manager or clients unmapping themselves, etc.  We have a few
 * options: we could try to figure out whenever something we do will
 * generate an EnterNotify event on a client and set a flag in the
 * client to ignore the event.  I did this, and the flag became an
 * integer variable as we might generate multiple EnterNotify events
 * for some things.  It also did not work very well as the server
 * seemed not to generate some EnterNotify events when another one was
 * pending (probably an optimization in the server).
 * 
 * Instead, we rely on two observations:
 * 
 * 1. When an EnterNotify is generated by a window unmappping, we will
 * first receive the UnmapNotify event, then the EnterNotify.  The
 * same goes for MapNotify, ConfigureNotify, GravityNotify and
 * CirculateNotify.
 * 
 * 2. Since the server must generate one of those events mentioned
 * above before the EnterNotify, it will probably generate them one
 * after another, in the same function most likely.  Thus, the server
 * will probably not service any of our requests in between generating
 * the UnmapNotify and the EnterNotify and the serial of the two
 * events will be the same.
 * 
 * The first observation is actually specified as a standard by the X
 * protocol document, but the second is not.  Therefore, it is
 * conceivable that this won't work on some X servers, but I haven't
 * seen that happen yet.
 */

static unsigned int ignore_enternotify_hack = 0;

static void update_ignore_enternotify_hack(XEvent *event);
static Time figure_timestamp(XEvent *event);

/*
 * One could also put a timeout handler here (WindowMaker does this),
 * and pass a different timeout value to select()
 */

void event_get(int xfd, XEvent *event)
{
    fd_set fds;

    for (;;) {
        if (XPending(dpy) > 0) {
            event_timestamp = figure_timestamp(event);
            XNextEvent(dpy, event);
            return;
        }
        FD_ZERO(&fds);
        FD_SET(xfd, &fds);
        if (select(xfd + 1, &fds, NULL, NULL, NULL) > 0) {
            continue;
        } else if (errno != EINTR) {
            perror("XWM: select:");
        }
    }
}

void event_dispatch(XEvent *event)
{
#ifdef DEBUG
    static char *xevent_names[] = {
        /* event name */        /* Do we handle it? */
        "Zero",                 /* NO */
        "One",                  /* NO */
        "KeyPress",             /* YES */
        "KeyRelease",           /* YES */
        "ButtonPress",          /* YES */
        "ButtonRelease",        /* YES */
        "MotionNotify",         /* special case */
        "EnterNotify",          /* YES */
        "LeaveNotify",          /* YES */
        "FocusIn",              /* TODO */
        "FocusOut",             /* TODO */
        "KeymapNotify",         /* TODO */
        "Expose",               /* YES */
        "GraphicsExpose",       /* NO? */
        "NoExpose",             /* NO? */
        "VisibilityNotify",     /* TODO */
        "CreateNotify",         /* YES */
        "DestroyNotify",        /* YES */
        "UnmapNotify",          /* YES */
        "MapNotify",            /* YES */
        "MapRequest",           /* YES */
        "ReparentNotify",       /* TODO */
        "ConfigureNotify",      /* TODO */
        "ConfigureRequest",     /* YES */
        "GravityNotify",        /* TODO */
        "ResizeRequest",        /* TODO */
        "CirculateNotify",      /* TODO */
        "CirculateRequest",     /* YES */
        "PropertyNotify",       /* YES */
        "SelectionClear",       /* NO */
        "SelectionRequest",     /* NO */
        "SelectionNotify",      /* NO */
        "ColormapNotify",       /* TODO */
        "ClientMessage",        /* YES */
        "MappingNotify",        /* TODO */
    };

    debug(("----------------------------------------"));
    debug(("----------------------------------------\n"));
    if (event->type > MappingNotify)
        debug(("%-19s unknown (%d)\n", "received event:", event->type));
    else
        debug(("%-19s %s (%d)\n", "received event:",
               xevent_names[event->type], event->type));
    xev_print(event);
#endif /* DEBUG */
    
    /* check the event number, jump to appropriate function */
    switch(event->type) {
        case 0:                 /* can't happen */
        case 1:
            fprintf(stderr, "XWM: received unusual event type %d\n",
                    event->type);
            break;
            
        case KeyPress:          /* XGrabKeys in keyboard.c */
        case KeyRelease:        /* XGrabKeys in keyboard.c */
            keyboard_handle_event(&event->xkey);
            break;
            
        case ButtonPress:       /* XGrabButton in mouse.c */
        case ButtonRelease:     /* XGrabButton in mouse.c */
            mouse_handle_event(event);
            break;
            
        case MotionNotify:
            /* the only way this can happen is if we have some stray
             * MotionNotify events left over in the event queue from
             * the move/resize code or elsewhere where we grab the mouse
             * and listen for these - harmless, ignore them */
            break;
            
        case EnterNotify:       /* frame EnterWindowMask, client.c */
            event_enter(&event->xcrossing);
            break;
            
/*        case LeaveNotify: */  /* ignored */
            
        case FocusIn:           /* frame FocusChangeMask, client.c */
            event_focusin(&event->xfocus);
            break;
            
/*        case FocusOut: */     /* TODO */
/*        case KeymapNotify: */ /* TODO */
            
        case Expose:            /* frame ExposureMask, client.c */
            event_expose(&event->xexpose);
            break;
            
/*        case GraphicsExpose: */ /* ignored */
/*        case NoExpose: */     /* ignored */
/*        case VisibilityNotify: */ /* TODO */
            
        case CreateNotify:      /* root SubstructureNotifyMask, xwm.c */
            event_create(&event->xcreatewindow);
            break;
            
        case DestroyNotify:     /* client StructureNotifyMask, client.c */
            event_destroy(&event->xdestroywindow);
            break;
            
        case UnmapNotify:       /* client StructureNotifyMask, client.c */
            update_ignore_enternotify_hack(event);
            event_unmap(&event->xunmap);
            break;
            
        case MapNotify:         /* client StructureNotifyMask, client.c */
            update_ignore_enternotify_hack(event);
            event_map(&event->xmap);
            break;
            
        case MapRequest:        /* root, frame SubstructureRedirectMask */
            event_maprequest(&event->xmaprequest);
            break;
            
/*        case ReparentNotify: */ /* TODO */
            
        case ConfigureNotify:
            update_ignore_enternotify_hack(event);
            break;
            
        case ConfigureRequest:  /* root, frame SubstructureRedirectmask */
            event_configurerequest(&event->xconfigurerequest);
            break;
            
        case GravityNotify:
            update_ignore_enternotify_hack(event);
            break;
            
/*        case ResizeRequest: */ /* TODO */
            
        case CirculateNotify:
            update_ignore_enternotify_hack(event);
            break;
            
        case CirculateRequest:  /* root, frame SubstructureRedirectMask */
            event_circulaterequest(&event->xcirculaterequest);
            break;
            
        case PropertyNotify:    /* client PropertyChangeMask, client.c */
            event_property(&event->xproperty);
            break;

/*        case SelectionClear: */ /* ignored */
/*        case SelectionRequest: */ /* ignored */
/*        case SelectionNotify: */ /* ignored */

        case ColormapNotify:
            event_colormap(&event->xcolormap);
            break;
            
        case ClientMessage:     /* client's in charge of this */
            event_clientmessage(&event->xclient);
            break;
            
/*        case MappingNotify: */ /* TODO */
            
        default:

#ifdef SHAPE
            if (shape_supported &&
                event->type == shape_event_base + ShapeNotify) {
                event_shape((XShapeEvent *)event);
            }
#endif /* SHAPE */
            debug(("\tIgnoring event\n"));
            break;
    }
}

/*
 * Focus and raise if possible
 * 
 * The problem is that sometimes we'll get EnterNotify events that and
 * we don't want to focus the window on those events - for example,
 * when the window under the pointer unmaps, it changes the window the
 * pointer is in and causes an EnterNotify on the new
 * window-under-pointer.  We only want to respond to this event when
 * the user moves the pointer, thus, ignore_enternotify_hack.
 * 
 * NB:  all of this is needed because we allow a
 * focus-follows-mouse-style processing without the assumption that
 * the window under the pointer gets the focus.
 * 
 * I've seen no other window manager that does this correctly -
 * they'll just force you to choose another window to focus or focus
 * the wrong window, which is clearly unacceptable.
 */

static void event_enter(XCrossingEvent *xevent)
{
    client_t *client;
    
    if (xevent->mode != NotifyNormal) {
        debug(("\tMode != NotifyNormal, ignoring event\n"));
        return;
    }
    
    /* If the mouse is NOT in the focus window but in some other
     * window and it moves to the titlebar of the window, it will
     * generate this event, and I don't want this to do anything
     */
    if (xevent->detail == NotifyInferior) {
        debug(("\tMode == NotifyInferior, ignoring event\n"));
        return;
    }

    client = client_find(xevent->window);
    client_print("EnterNotify", client);
    if (client != NULL && client->state == NormalState
        && xevent->serial != ignore_enternotify_hack
        && client->focus_policy == SloppyFocus) {
        debug(("\tSetting focus in response to EnterNotify\n"));
        focus_set(client, CurrentTime);
    } else {
        debug(("\tNot setting focus\n"));
    }
}

/*
 * create client structure, basically manage the window
 */

static void event_create(XCreateWindowEvent *xevent)
{
    client_t *client;

    if (xevent->override_redirect) {
        debug(("\tWindow %#lx has override_redirect, ignoring\n",
               (unsigned int)xevent->window));
        return;
    }

    client = client_create(xevent->window);
    client_print("Create:", client);
    if (client == NULL) return;
}

/*
 * remove client structure
 */

static void event_destroy(XDestroyWindowEvent *xevent)
{
    client_t *client;
    
    client = client_find(xevent->window);
    client_print("Destroy:", client);
    if (client == NULL) {
        return;
    }
    if (client->window != xevent->window) return;

    /* we will always receive an UnmapNotify before a DestroyNotify (X
     * spec says that's how it has to be) and most of the work is done
     * when the window is unmapped. */
    
    client_destroy(client);
}

/*
 * ICCCM 4.1.4:
 * 
 * "For compatibility with obsolete clients, window managers should
 * trigger the transition to the Withdrawn state on the real
 * UnmapNotify rather than waiting for the synthetic one. They should
 * also trigger the transition if they receive a synthetic UnmapNotify
 * on a window for which they have not yet received a real UnmapNotify."
 * 
 * Which means that we simply set the state to Withdrawn if we receive
 * any kind of unmap request.  Most other window managers also
 * reparent the window to the root window when it's unmapped so that
 * it doesn't get mapped again if the window manager exits.  I'm not
 * going to deal with that since I don't use X that way (window
 * manager crashes = you're screwed).
 */

static void event_unmap(XUnmapEvent *xevent)
{
    client_t *client;
    
    client = client_find(xevent->window);

    client_print("Unmap:", client);
    if (client == NULL) {
        debug(("\tIgnoring UnmapNotify for unknown client\n"));
        return;
    }

    /* rarely may get a MapNotify from listening for
     * SubstructureNotify on the root window, we ignore these (will
     * get another event shortly which we deal with) */
    if (xevent->event == root_window) {
        debug(("\tIgnoring event generated by root window\n"));
        return;
    }

    /* if we unmapped it ourselves (like below), no need to do anything else */
    if (xevent->window != client->window) {
        debug(("\tNot doing anything in event_unmap\n"));
        return;
    }

    if (client->ignore_unmapnotify != 0) {
        debug(("\tClient has ignore_unmapnotify\n"));
        client->ignore_unmapnotify = 0;
        return;
    }
    
    /* well, at this point, we need to do some things to the window
     * (such as setting the WM_STATE property on the window to
     * Withdrawn as per ICCCM), but the problem is that the client may
     * have already destroyed the window, and the server may have
     * already processed the destroy request, which makes the window
     * invalid.  I can't think of any way of figuring out if the
     * window is still valid other than grabbing the server and seeing
     * if some request on that window fails.  In any case, we have to
     * receive some sort of error, and since we don't care if the
     * requests we are about to make succeed or fail, we just ignore
     * the errors they can cause.  We get BadWindow errors everywhere
     * throughout the window manager, but this particular area creates
     * the majority of them. */

    debug(("\tRemoving from focus list\n"));
    focus_remove(client, event_timestamp);
    
    if (client->state == NormalState) {
        ewmh_client_list_remove(client);
        debug(("\tUnmapping frame in event_unmap\n"));
        XUnmapWindow(dpy, client->frame);
    }
    client->state = WithdrawnState;
    debug(("\tUnreparenting\n"));
    client_unreparent(client);
    
    client_inform_state(client);
}

/*
 * Map the client and the frame, update WM_STATE on the client window
 */

static void event_maprequest(XMapRequestEvent *xevent)
{
    client_t *client;
    Bool addfocus;

    client = client_find(xevent->window);
    client_print("Map Request:", client);
    if (client == NULL) {
        fprintf(stderr, "XWM: unable to find client, shouldn't happen\n");
        return;
    }
    if (client->state == NormalState) {
        /* This should never happen as XMapWindow on an already-mapped
         * window should never generate an X request, but better be
         * safe (don't want to raise a window randomly) */
        addfocus = False;
    } else {
        addfocus = True;
    }

    if (client->xwmh != NULL && client->state == WithdrawnState) {
        client->state = client->xwmh->initial_state;
        if (client->state != IconicState)
            client->state = NormalState;
    } else {
        client->state = NormalState;
    }
    if (client->workspace == 0) {
        client->workspace = workspace_current;
        if (client->titlebar != None) {
            XSetWindowAttributes xswa;
            xswa.background_pixel =
                workspace_darkest_highlight[workspace_current - 1];
            XChangeWindowAttributes(dpy, client->titlebar, CWBackPixel, &xswa);
        }
    }

    if (client->state == NormalState
        && client->workspace == workspace_current) {
        if (client->reparented == 0)
            client_reparent(client);
        if (client->xsh == NULL
            || !(client->xsh->flags & (USPosition | PPosition)))
            place(client);
        XMapWindow(xevent->display, client->window);
        stacking_raise(client);
        if (client->titlebar != None) {
            XMapWindow(xevent->display, client->titlebar);
        }
        keyboard_grab_keys(client->frame);
        mouse_grab_buttons(client);
        if (addfocus) {
            focus_add(client, event_timestamp);
        }
    }

    client_inform_state(client);
    XFlush(dpy);                /* FIXME:  remove these two, kicker */
    XSync(dpy, False);
}

/*
 * update our idea of client's geometry, massage request
 * according to client's gravity if it has a title bar
 */

static void event_configurerequest(XConfigureRequestEvent *xevent)
{
    client_t *client;
    XWindowChanges xwc;
    position_size ps;
    unsigned long new_mask;
    XEvent ev;
    int title_height;

    client = client_find(xevent->window);

    if (client == NULL) {
        fprintf(stderr,
                "XWM: Got ConfigureRequest from unknown client, "
                "shouldn't happen\n");
        return;
    }

    client_print("Configure Request:", client);
    
    debug(("\tBefore: %dx%d+%d+%d\n", client->width, client->height,
           client->x, client->y));

    ps.x = client->x;
    ps.y = client->y;
    ps.width = client->width;
    ps.height = client->height;
    
    debug(("\tClient is changing: "));
    if (xevent->value_mask & CWX) {
        client->prev_x = client->prev_width = -1;
        ps.x = xevent->x;
        debug(("x "));
    }
    if (xevent->value_mask & CWY) {
        client->prev_y = client->prev_height = -1;
        ps.y = xevent->y;
        debug(("y "));
    }
    if (xevent->value_mask & CWWidth) {
        client->prev_x = client->prev_width = -1;
        ps.width = xevent->width;
        debug(("width "));
    }
    if (xevent->value_mask & CWHeight) {
        client->prev_y = client->prev_height = -1;
        ps.height = xevent->height;
        debug(("height "));
    }
    if (xevent->value_mask & CWBorderWidth) {
        client->orig_border_width = xevent->border_width;
        debug(("border_width "));
    }
    if (xevent->value_mask & CWSibling) {
        debug(("sibling "));
    }
    if (xevent->value_mask & CWStackMode) {
        debug(("stack_mode "));
    }
    debug(("\n"));

    client_frame_position(client, &ps);
    if (xevent->value_mask & CWX) client->x = ps.x;
    if (xevent->value_mask & CWY) client->y = ps.y;
    if (xevent->value_mask & CWWidth) client->width = ps.width;
    if (xevent->value_mask & CWHeight) client->height = ps.height;
    
    xwc.x            = client->x;
    xwc.y            = client->y;
    xwc.width        = client->width;
    xwc.height       = client->height;
    xwc.border_width = 0;
    xwc.sibling      = xevent->above;
    xwc.stack_mode   = xevent->detail;

    new_mask = xevent->value_mask & (~(CWSibling | CWStackMode | CWBorderWidth));
    XConfigureWindow(dpy, client->frame, new_mask, &xwc);
    if (client->titlebar != None && (xevent->value_mask & CWWidth))
        XConfigureWindow(dpy, client->titlebar, CWWidth, &xwc);

    title_height = client->titlebar == None ? 0 : TITLE_HEIGHT;
    xwc.y = title_height;
    xwc.height -= title_height;
    xwc.x = 0;
    if (new_mask != 0) {
        XConfigureWindow(xevent->display, client->window, new_mask, &xwc);
    } else {
        debug(("\tSending fake ConfigureNotify\n"));
        ev.type = ConfigureNotify;
        ev.xconfigure.display = dpy;
        ev.xconfigure.event = client->window;
        ev.xconfigure.window = client->window;
        ev.xconfigure.x = client->x;
        ev.xconfigure.y = client->y + title_height;
        ev.xconfigure.width = client->width;
        ev.xconfigure.height = client->height - title_height;
        ev.xconfigure.border_width = client->orig_border_width;
        ev.xconfigure.above = None;
        XSendEvent(dpy, client->window, True, NoEventMask, &ev);
    }

#if 0                           /* FIXME */
    if (xevent->value_mask & CWStackMode) {
        /* FIXME:  deal with the sibling, Opposite correctly */
        /* we will completely ignore stacking requests for
         * transient clients and clients which have transients -
         * some applications try to ensure transients remain
         * above the leader, but we'll do that ourselves */
        if (xevent->detail == Above
            && client->transients == NULL
            && client->transient_for == None) {
            debug(("\tRaising window\n"));
            XRaiseWindow(dpy, client->frame);
        } else if (xevent->detail == Below
                   && client->transients == NULL
                   && client->transient_for == None) {
            debug(("\tLowering window\n"));
            XLowerWindow(dpy, client->frame);
        } else {
            debug(("\tIgnoring stacking request %d for client %#lx (%s)\n",
                   xevent->detail, (unsigned int)client, client->name));
        }
    }
#endif
    debug(("\tAfter: %dx%d+%d+%d\n", client->width, client->height,
           client->x, client->y));
}

/*
 * window property changed, update client structure
 */

static void event_property(XPropertyEvent *xevent)
{
    client_t *client;

    client = client_find(xevent->window);
    if (client == NULL) return;
    if (xevent->atom == XA_WM_NAME) {
        /* move-resize.c takes over client->name while
         * moving or resizing and then resets value */
        if (moving || sizing) return;
        debug(("\tWM_NAME, changing client->name\n"));
        Free(client->name);
        client_set_name(client);
        client_paint_titlebar(client);
    } else if (xevent->atom == XA_WM_CLASS) {
        debug(("\tWM_CLASS, changing client->[class, instance]\n"));
        if (client->class != None) XFree(client->class);
        if (client->instance != None) XFree(client->instance);
        client_set_instance_class(client);
    } else if (xevent->atom == XA_WM_HINTS) {
        debug(("\tWM_HINTS, changing client->xwmh\n"));
        if (client->xwmh != NULL && client->group_leader == NULL)
            XFree(client->xwmh);
        client_set_xwmh(client);
    } else if (xevent->atom == XA_WM_NORMAL_HINTS) {
        debug(("\tWM_NORMAL_HINTS, changing client->xsh\n"));
        if (client->xsh != None) XFree(client->xsh);
        client_set_xsh(client);
    } else if (xevent->atom == WM_PROTOCOLS) {
        debug(("\tWM_PROTOCOLS, changing client->protocols\n"));
        client_set_protocols(client);
    } else if (xevent->atom == XA_WM_TRANSIENT_FOR) {
        client_set_transient_for(client);
    }
}

static void event_colormap(XColormapEvent *xevent)
{
    /* FIXME: deal with this later */
}

/*
 * The only thing we look for here is if the window wishes to iconize
 * itself as per ICCCM 4.1.4
 */

static void event_clientmessage(XClientMessageEvent *xevent)
{
    client_t *client;
    
    if (xevent->message_type == WM_CHANGE_STATE) {
        /* ICCCM 4.1.4 */
        client = client_find(xevent->window);
        if (xevent->format == 32 && xevent->data.l[0] == IconicState) {
            debug(("\tClient insists on iconifying itself, placating it\n"));
            debug(("\tUnmapping frame in event_clientmessage\n"));
            debug(("\tUnmapping window in event_clientmessage\n"));
            XUnmapWindow(dpy, client->frame);
            XUnmapWindow(dpy, client->window);
            client->state = IconicState;
            client_inform_state(client);
            focus_remove(client, event_timestamp);
            ewmh_client_list_remove(client);
        }
    } else {
        ewmh_handle_clientmessage(xevent);
    }
}

static void event_circulaterequest(XCirculateRequestEvent *xevent)
{
    /* generated by XCirculateSubwindows, nobody uses this */
    fprintf(stderr, "XWM: Received CirculateRequest, ignoring it\n");
}

/*
 * Should only get this if titlebar needs repainting; we simply
 * repaint the whole thing at once.
 */

static void event_expose(XExposeEvent *xevent)
{
    client_t *client;

    /* simple, stupid */
    if (xevent->count != 0) return;
    
    client = client_find(xevent->window);
    if (client != NULL)
        client_paint_titlebar(client);
}

/*
 * Only does anthing if client is using Globally Active focus (see
 * ICCCM) or if client stole the focus.
 */

static void event_focusin(XFocusChangeEvent *xevent)
{
#if 0 /* FIXME */
    client_t *client;
    
    /* we could get a couple of these in a row and then
     * we start generating loads of these events - very
     * nasty bug, keeps bouncing the focus everywhere */
    while (XCheckTypedEvent(dpy, FocusIn, (XEvent *)xevent));
    
    if (xevent->type == FocusIn
        && xevent->mode == NotifyNormal
        && xevent->detail == NotifyNonlinearVirtual) {
        /* someone stole our focus without asking for permission */
        client = client_find(xevent->window);
        client_print("FocusIn", client);
        if (client == NULL) {
            fprintf(stderr, "XWM: Could not find client on FocusIn event\n");
            return;
        }
        debug(("\tSetting focus\n"));
        focus_set(client, event_timestamp); /* FIXME:  shouldn't XSetInputFocus */
    } else {
        debug(("\tNot setting focus\n"));
    }
#endif
}

/*
 * Occasionally we map a window and then immediately give it the focus
 * - however, we get a BadMatch error if the window hasn't yet been
 * made visible by the server.  This function ensures we always focus
 * what we want to focus.  workspace.c does something similar, but it
 * doesn't hurt to have some redundancy (having the wrong window
 * focused is a CATASTROPHIC FAILURE for a window manager)
 */

static void event_map(XMapEvent *xevent)
{
    client_t *client;

    client = client_find(xevent->window);
    if (client != NULL
        && xevent->window == xevent->event
        && client->frame == xevent->window) {
        ewmh_client_list_add(client);
    }
    if (client != NULL
        && client->window == xevent->window
        && client == focus_current) {
        debug(("\tCalling XSetInputFocus\n"));
        XSetInputFocus(dpy, client->window, RevertToPointerRoot, CurrentTime);
    } else {
        debug(("\tNot calling XSetInputFocus\n"));
    }
}

/*
 * If we get this, we update our frame to match the client's shape and
 * get rid of the titlebar if the client has one.
 */

#ifdef SHAPE
static void event_shape(XShapeEvent *xevent)
{
    XRectangle *rectangles;
    int n_rects, junk;
    client_t *client;

    client = client_find(xevent->window);
    if (client == NULL) return;
    if ( (rectangles = XShapeGetRectangles(dpy, xevent->window,
                                           ShapeBounding, &n_rects,
                                           &junk)) == NULL)
        return;
    if (rectangles != NULL) XFree(rectangles);
    if (n_rects <= 1)
        return;
    client->is_shaped = 1;
    if (client->has_titlebar) {
        XShapeCombineShape(dpy, client->frame, ShapeBounding, 0,
                           TITLE_HEIGHT, client->window,
                           ShapeBounding, ShapeSet);
        XShapeCombineShape(dpy, client->frame, ShapeBounding, 0, 0,
                           client->titlebar, ShapeBounding, ShapeUnion);
    } else {
        XShapeCombineShape(dpy, client->frame, ShapeBounding, 0, 0,
                           client->window, ShapeBounding, ShapeSet);
    }
}
#endif /* SHAPE */

static void update_ignore_enternotify_hack(XEvent *event)
{
    ignore_enternotify_hack = event->xany.serial;
    XSync(dpy, False);
}

/* 
 * all events defined by Xlib have common first few members, so just
 * use any arbitrary event structure to get the window if the event is
 * defined by Xlib
 */
Window event_window(XEvent *event)
{
    if (event->type > 1 && event->type < LASTEvent) {
        return event->xbutton.window;
    } else {
        return None;
    }
}

/* not all events have a timestamp, some have it in the same place */
static Time figure_timestamp(XEvent *event)
{
    switch (event->type) {
        case ButtonPress:
        case ButtonRelease:
        case KeyPress:
        case KeyRelease:
        case MotionNotify:
        case EnterNotify:
        case LeaveNotify:
            return event->xbutton.time;
        case PropertyNotify:
        case SelectionClear:
            return event->xproperty.time;
        case SelectionRequest:
            return event->xselectionrequest.time;
        case SelectionNotify:
            return event->xselection.time;
        default:
#ifdef SHAPE
            if (event->type == shape_event_base + ShapeNotify)
                return ((XShapeEvent *)event)->time;
#endif /* SHAPE */
            return CurrentTime;
    }
}
